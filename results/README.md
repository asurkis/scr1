# Лабораторная работа Lab3 SCR1 RTL
## Цель
Исследование микроархитектуры и расширение функционала процессора SCR1

## Задание
| Вариант | Инструкция | Описание |
| --- | --- | --- | --- | --- | --- |
| 15 | Concatenation with immediate (`CNCI`) | `CNCI`: Конкатенация старших 20-bit регистра `RS1` и младших 12-bit константы, результат поместить в `RD` |

В вашем репозитории SCR1 от главной ветки master создать новую ветку с именем lab_rtl. В этой ветке вы можете коммитить все изменения проекта для данной лабораторной.

Убедитесь, что проект собирается и все тесты проходят в симуляции до внесения изменений в проект. Также убедитесь, что вы можете посмотреть вейвформы симуляции. Если вы используете Verilator в качестве симулятора, то для данной лабораторной вам нужно будет запускать его в режиме с генерацией вейвформ (`run_verilator_wf`).

Создайте в директории `./results` файл `README.md` с отчетом по проделанной работе. В отчете обязательно указать свой вариант задания.

### Добавление кастомной инструкции

1. Добавить в исходный код ядра новую кастомную инструкцию в соответствии с вариантом задания.
1. Способ машинного кодирования новой инструкции (расположение полей и значения opcode, funct и пр.) необходимо выбрать самостоятельно из области незарезервированных в RISC-V ISA опкодов. В отчете объяснить ваш выбор кодирования инструкции.
1. Поясните в виде блок-схемы или словесного описания в отчете какие изменения вы внести, в какие блоки и почему именно так.

Верификация

1. Написать ассемблерный тест для проверки новой инструкции. Так как компилятор ничего не знает о вашей кастомной инструкции, вместо мнемонического представления следует задавать ее как

        .word <инструкция в машинном коде> // комментарий с расшифровкой или мнемоникой

1. Тест должен покрывать несколько типичных случаев, в которых возможна ошибка. Поясните в отчете каждый выбранный вами типичный случай, на сколько хорошее тестовое покрытие будет обеспечено этим тестом.
1. Для отладки вы можете пользоваться Waveform (просмотр уровней внутренних сигналов rtl схемы), Dump, Tracelog. Приложите эти файлы в директорию ./results. Выведите на Waveform основные сигналы, которые показывают правильность прохождения инструкции по конвейеру - поясните в отчете ваш выбор.

## Выполнение
1. Запустил `make clean; make`, чтобы убедиться, что успешно проходят все тесты.
1. Создал файл `dependencies/riscv-tests/MyTest.S`:

        #include "riscv_test.h"

        RVTEST_RV32U

        RVTEST_CODE_BEGIN
                la      t0, testdata
                lw      t1, 0(t0)
                addi    t1, t1, 1
                la t0, result
                sw      t1, 0(t0)
                li      t3, 42
                bne     t1, t3, fail
                RVTEST_PASS
        fail:
                RVTEST_FAIL
        RVTEST_CODE_END

        .data
                .align 3
        testdata:
                .dword 41

        RVTEST_DATA_BEGIN
                .align 3
            result:
                .dword -1
        RVTEST_DATA_END

1. Добавил строку 68: `rv32_isa_tests = MyTest.S` к `sim/tests/riscv_isa/rv32_tests.inc`.
1. Запустил `make clean; make TARGETS=riscv_isa`, чтобы убедиться, что успешно проходит
    тест `MyTest`.
1. Заменил `li x3, 42` на `li x3, 43` в `MyTest.S` и убедился, что тест не проходит.
    В дальнейшем этот тест будет заменен на тест синтезируемой команды.
1. Решил использовать вид кодирования "I" (I-type),
    поскольку моя инструкция принимает регистр и младшие 12 бит константы на вход
    и регистр на выход.
    Аналогичные виды кодирования используют инструкции по типу `addi`,
    но добавить свою инструкцию в тот же `opcode` не получилось,
    т.к. все возможные значения `funct3` на `opcode = 0010011` уже распределены.
    Поэтому нужно выделить новый `opcode`.
1. Нашел неиспользуемый в RISC-V `opcode` 0001011.
    Последние два бита отвечают за тип машинной команды,
    а именно &mdash; 32-битная инструкция (RVI),
    остальные можно перебирать, что я и сделал.
1. Заменил строку 36 на строки 36-37 в файле `src/core/includes/scr1_riscv_isa_decoding.svh`:

        SCR1_OPCODE_SYSTEM  = 5'b11100,
        SCR1X_OPCODE_OP_IMM = 5'b00010
1. Добавил строки 87-88 в файле `src/core/includes/scr1_riscv_isa_decoding.svh`:

        ,
        SCR1X_IALU_CMD_CAT
1. Изменил строки 55 и 57 в файле `src/core/includes/scr1_riscv_isa_decoding.svh`:

        `ifdef SCR1_RVM_EXT
        localparam SCR1_IALU_CMD_ALL_NUM_E    = 24;
        `else // ~SCR1_RVM_EXT
        localparam SCR1_IALU_CMD_ALL_NUM_E    = 16;
1. Добавил строки 466-479 в файле `src/core/pipeline/scr_pipe_idu.sv`

        SCR1X_OPCODE_OP_IMM: begin
            idu2exu_use_rs1_o         = 1'b1;
            idu2exu_use_rd_o          = 1'b1;
            idu2exu_use_imm_o         = 1'b1;
            idu2exu_cmd_o.imm         = {{20{0}}, instr[31:20]};
            idu2exu_cmd_o.ialu_op     = SCR1_IALU_OP_REG_IMM;
            idu2exu_cmd_o.rd_wb_sel   = SCR1_RD_WB_IALU;

            case (funct3)
                3'b000: idu2exu_cmd_o.ialu_cmd = SCR1X_IALU_CMD_CAT;
                default: rvi_illegal = 1'b1;
            endcase // funct3
        end // SCR1X_OPCODE_OP_IMM

    Этот код, по аналогии с обработчиком `SCR1_OPCODE_OP_IMM`,
    декодирует команду как использующую один исходный регистр,
    один регистр для вывода, константу,
    задает младшие 12 бит константы как старшие 12 бит инструкции,
    старшие 20 бит константы заполняет нулями,
    режим ввода АЛУ как "регистр-константа",
    решим вывода АЛУ как "writeback" (запись в регистр после выполнения),
    операция в АЛУ &mdash; объявленная операция конкатенации
